<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<title>Vermogen Meter</title>
				<style>
					/* General Gauge Styles */
					.gauge {
						--size: 250px;
						--cutout: 50%;
						--background: white;
						width: var(--size);
						height: var(--size);
						border-radius: 50%;
						outline: 1.5px solid gray;
						box-shadow: inset 0 0 0 1.5px gray;
						display: flex;
						justify-content: center;
						align-items: center;
						position: relative;
					}
					
					.x-axis-line {
						position: absolute;
						top: 50%;
						left: -10%;
						width: 150%;
						height: 2px;
						background-color: grey;
						transform: translateY(-50%);
					}
					
					
					.primary_indicator {
						position: absolute;
						top: 52%;
						left: 50%;
						transform: translate(-50%, -50%);
						font-size: 2rem;
						font-weight: bold;
						color: rgb(100, 200, 100); /* Initial color */
						transition: color 0.2s linear;
						text-align: center;
					}
					
					.primary_indicator .label {
						font-size: 1.5rem;
						font-weight: bold;
						color: #666; /* Dimmed */
						white-space: nowrap; /* Prevent text from wrapping */
					}

					
					.primary_indicator .unit{
						display: inline;
						margin-left: 2px; /* Small spacing between value and unit */
					}
					
					.secondary_indicator {
						position: absolute;
						margin-left: 10px; /* Place it to the right of the gauge */
						left: 100%; /* Place it to the right of the gauge */
						top: 50%; /* Position it at the middle vertically */
						transform: translateY(-50%); /* Adjust it to be centered by moving up by half of its height */
						/* Additional styling like padding, font-size, etc. */
					}
					
					.secondary_indicator .label {
						font-size: 1.5rem;
						font-weight: bold;
						color: red;
						white-space: nowrap; /* Prevent text from wrapping */
					}
					
					.secondary_indicator .value {
						font-size: 1.5rem;
						font-weight: bold;
						color: red;
						margin-bottom: 5px;
						transition: color 0.2s linear;
						display: inline-flex; /* Keep the unit inline with the value */
						align-items: baseline; /* Align baseline for a natural look */
					}
					
					.secondary_indicator .unit {
						color: red;
						display: inline;
						margin-left: 2px; /* Small spacing between value and unit */
					}
					
				</style>
			</head>
	<body>
		
		<div class="gauge">
			<div class="x-axis-line"></div>
			<div class="primary_indicator">
				<div class="label" data-customLabel="Netto Vermogen"></div>
				<div class="value-container">
					<span class="value">0.0</span><span class="unit"></span>
				</div>
			</div>
			<div class="secondary_indicator">
				<div class="label" data-customLabel="Maandpiek"></div>
				<div class="value-container">
					<span class="value">0.0</span><span class="unit"></span>
				</div>
			</div>
		</div>
		
		<script>
			let baseURL = "";
			let userName = "";
			let password = "";
			window.onload = async function() {
				await loadSettings();  // Wait for the settings to load first
				updateGaugeValues();         // Then call updateGaugeValues after settings are loaded
				setInterval(updateGaugeValues, 5000); // Set the interval to call every 5 seconds
			};
			
			const ENDPOINTS = {
				"powerDelivered": "power_delivered",
				"powerReturned": "power_returned",
				"secondary_indicator": "highest_peak_pwr",
			};
			
			const powerIndicator = document.querySelector(".primary_indicator");
			const secondaryIndicator = document.querySelector(".secondary_indicator");
			let indicatorValues = [];
			
			async function updateGaugeValues() {
				try {
					const data = await fetchValues(); // Get all the JSON data
					
					let indicatorToConnect;
					let indicatorData;
					let htmlLabel;
					let htmlValue;
					let htmlUnit;
					
					let powerDelivered = null;
					let powerReturned = null;
					
					// Loop through the tagged data and
					// if the tag matches some indicator, automatically attach the data to that indicator
					Object.entries(data).forEach(([endpointTag, endpointData]) => {
						
						indicatorToConnect = document.querySelector("." + endpointTag);
						indicatorData = composeIndicatorData(endpointTag, endpointData);
						
						switch (endpointTag) {
							case "powerDelivered":
							powerDelivered = composeIndicatorData("powerDelivered", endpointData).value;
							break;
							case "powerReturned":
							powerReturned = composeIndicatorData("powerReturned", endpointData).value;
							
							if ((powerDelivered != null) && (powerReturned != null)) {
								const nettoPower = powerDelivered - powerReturned;
								indicatorValues.push(nettoPower);
								
								// When everything is in place to update the gauge, do so
								if (powerIndicator && nettoPower) {
									console.log("Updating primary indicator with nettoPower:", nettoPower);
									htmlLabel = powerIndicator.querySelector(".label");
									htmlvalue = powerIndicator.querySelector(".value");
									htmlUnit = powerIndicator.querySelector(".unit");
									if (htmlLabel == null || htmlvalue == null || htmlUnit == null) {
										console.error("‚ö†Ô∏è Missing HTML elements for primary indicator");
										break;
									}
									
									// Update text content of the HTML elements
									
									// Check to see if a custom label is provided
									const customLabel = htmlLabel.getAttribute("data-customLabel");
									if (customLabel != null) {  // Fix: added parentheses around condition
										htmlLabel.textContent = customLabel;
									} else {
										htmlLabel.textContent = indicatorData.quantity;
									}
									htmlvalue.textContent = nettoPower.toFixed(3);      // Update value
									htmlUnit.textContent = "kW";               // Update unit
								}
							}
							break;
							
							case "secondary_indicator":
							autoConnect(indicatorToConnect, indicatorData);
							break;
							
							default:
							console.warn("‚ö†Ô∏è No handler for endpoint: " + endpointTag);
							break;
						}
					});
					
					// Update gauge scale based on both indicatorValues
					updateGaugeStyle(indicatorValues[0], indicatorValues[1]);
					
				} catch (error) {
					console.error("‚ùå Error in updateGaugeValues:", error);
				}
			}
			
			function autoConnect(indicatorToConnect, indicatorData) {
				if ((indicatorToConnect != null) && (indicatorData != null)) {
					// Always store values for indicators that can be autoconnected
					indicatorValues.push(indicatorData.value);
					
					// Select child elements within this indicator
					const htmlLabel = indicatorToConnect.querySelector(".label");
					const htmlvalue = indicatorToConnect.querySelector(".value");
					const htmlUnit = indicatorToConnect.querySelector(".unit");
					
					// Update text content of the HTML elements
					
					// Check to see if a custom label is provided
					const customLabel = htmlLabel.getAttribute("data-customLabel");
					if (customLabel != null) {  // Fix: added parentheses around condition
						htmlLabel.textContent = customLabel;
					} else {
						htmlLabel.textContent = indicatorData.quantity;
					}
					
					htmlvalue.textContent = indicatorData.value.toFixed(3);
					htmlUnit.textContent = indicatorData.unit ?? "";
				} else {
					console.error("‚ö†Ô∏è Autconnection indicator failed");
				}
			}
			
			function updateGaugeStyle(nettoPower, maxPower) {
				
				// The angles used to define the gradient for the scale
				// are based on a system where zero degrees is midscale or 12 o'clock
				// Gradients that start with a 'from' parameter will start at the specified angle and
				// gradientpoints are defined relative from that angle
				const gauge = document.querySelector(".gauge");
				
				// Define abosolute angle that the scale will start at
				const startOfScale = -135;
				
				// Define relative angles within that scale
				const minScale = 0;
				const nominalMin = 45;
				const nominalMax = 225;
				const maxScale = 270;
				
				// NettoPower expressed as an angle within the scale
				const percentage = (nettoPower / maxPower);
				const nominalRange = (nominalMax - nominalMin);
				let currentAngle = nominalMin+(percentage * nominalRange);
				// Always limit the angle within the defined ranges
				if (currentAngle <= minScale) {
					currentAngle = minScale;
				}
				if (currentAngle >= maxScale) {
					currentAngle = maxScale;
				}
				
				const gaugeCenter = `radial-gradient(var(--background) 0 var(--cutout), transparent var(--cutout) 100%)`;
				const gaugeScale = `conic-gradient(from ${startOfScale}deg, 
green ${minScale}deg ${nominalMin}deg, 
yellow,
orange, 
red ${nominalMax}deg ${maxScale}deg, 
transparent ${maxScale}deg 360deg
)`;
				let scaleCover
				if (nettoPower >= 0) {
					scaleCover = `conic-gradient(from ${startOfScale}deg, 
rgba(255, 255, 255, 0.75) ${startOfScale}deg ${nominalMin}deg, 
transparent ${nominalMin}deg ${currentAngle}deg,
rgba(255, 255, 255, 0.75) ${currentAngle}deg  ${maxScale}deg,
transparent ${maxScale}deg 360deg 
)`;
				} else {
					scaleCover = `conic-gradient(from ${startOfScale}deg, 
rgba(255, 255, 255, 0.75) ${startOfScale}deg  ${currentAngle}deg,
transparent ${currentAngle}deg ${nominalMin}deg,
rgba(255, 255, 255, 0.75) ${nominalMin}deg ${maxScale}deg,
transparent ${maxScale}deg 360deg 
)`;
				}
				
				// Apply the gauge components as CSS background
				gauge.style.background = `${scaleCover},${gaugeCenter},${gaugeScale}`;
			}
			
			
			// Subroutines
			async function loadSettings() {
				try {
					const response = await fetch("/DSMRsettings.json");  // Fetch the config file from the ESP32
					if (!response.ok) throw new Error("‚ùå Failed to load config");
					
					const settings = await response.json();  // Parse JSON
					
					const hostName = settings.Hostname;
					baseURL = "http://" + hostName + ".local/api/v2/sm/fields/".toLowerCase();
					const credentials = settings["basic-auth"];
					userName = credentials.user;
					password = credentials.pass;
					
					console.log("‚öôÔ∏è‚úÖ Settings loaded");
					
				} catch (error) {
					console.error("‚ùå Error loading config:", error);
				}
			}
			
			async function fetchValues() {
				const headers = new Headers();
				headers.set("Authorization", "Basic " + btoa(userName + ":" + password));
				headers.set("Content-Type", "application/json");
				
				const requests = Object.entries(ENDPOINTS).map(async ([endpointTag, endpoint]) => {
					const cleanbaseURL = baseURL.replace(/\/$/, ""); // Ensure baseURL does not end with '/'
					const cleanEndpoint = endpoint.replace(/^\//, ""); // Ensure endpoint does not start with '/'
					
					const url = cleanbaseURL + "/" + cleanEndpoint;
					try {
						console.log("%c‚è¨Ô∏è Fetching: " + url, "color: grey;");
						const response = await fetch(url, { method: "GET", headers });
						
						if (!response.ok) {
							throw new Error("‚ùå Error " + response.status + ": " + response.statusText);
						}
						const jsonData = await response.json();
						console.log("üü¢‚á£ Response: ", jsonData);
						return [endpointTag, jsonData]; // Return as a key-value pair
						
					} catch (error) {
						console.error("‚ùå Fetch error for " + endpointTag + ":", error);
						return [endpointTag, null]; // Keep consistent structure
					}
				});
				
				// Await all requests and return as an object
				return Object.fromEntries(await Promise.all(requests));
			}
			
			function composeIndicatorData(endpointTag, endpointData) {
				const valuesKey = Object.keys(endpointData).find(key => key !== "timestamp"); // Find a key other than "timestamp"
				const values = endpointData[valuesKey]; // Get the values associated with that key
				const indicatorData = { quantity: endpointTag, ...values }; // Merge tag and values
				return indicatorData;
			}
			
		</script>
	</body>
</html>
