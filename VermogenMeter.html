<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<title>Vermogen Meter</title>
				<style>
					/* General Gauge Styles */
					.gauge {
						--size: 250px;
						--cutout: 50%;
						--background: white;
						width: var(--size);
						height: var(--size);
						border-radius: 50%;
						outline: 1.5px solid gray;
						box-shadow: inset 0 0 0 1.5px gray;
						display: flex;
						justify-content: center;
						align-items: center;
						position: relative;
					}
					
					/* Primary Indicator */
					.primary_indicator,
					.secondary_indicator {
						position: absolute;
						bottom: 0;
						left: 50%;
						transform: translateX(-50%);
						text-align: center;
					}
					
					.primary_indicator {
						position: absolute;
						top: 50%;
						left: 50%;
						transform: translate(-50%, -50%);
						font-size: 2rem;
						font-weight: bold;
						color: rgb(100, 200, 100); /* Initial color */
						transition: color 0.2s linear;
						text-align: center;
					}
					
					.primary_indicator .label {
						font-size: 1.5rem;
						font-weight: bold;
						color: #666; /* Dimmed */
					}
					
					.primary_indicator .value,
					.secondary_indicator .value {
						display: inline-block;
						font-size: 2rem;
						font-weight: bold;
						color: #333;
						transition: color 0.2s linear;
					}
					
					.primary_indicator .unit,
					.secondary_indicator .unit {
						display: inline-block;
						margin-left: 2px; /* Small spacing between value and unit */
					}
					
					/* Secondary Indicator */
					.secondary_indicator {
						position: absolute;
						bottom: 0; /* Set to position at the very bottom */
						left: 50%;
						transform: translateX(-50%);
						text-align: center;
					}
					
					.secondary_indicator .label {
						font-size: 1.5rem;
						font-weight: bold;
						color: #666; /* Dimmed */
					}
					
					.secondary_indicator .value {
						font-size: 1.5rem;
						font-weight: bold;
						color: #333;
						margin-bottom: 5px;
						transition: color 0.2s linear;
						display: inline-flex; /* Keep the unit inline with the value */
						align-items: baseline; /* Align baseline for a natural look */
					}
					
					.secondary_indicator .unit {
						display: inline;
						margin-left: 2px; /* Small spacing between value and unit */
					}
				</style>
			</head>
	<body>
		
		<div class="gauge">
			<div class="primary_indicator">
				<div class="label"></div>
				<div class="value-container">
					<span class="value">0.0</span><span class="unit"></span>
				</div>
			</div>
			<div class="secondary_indicator">
				<div class="label"></div>
				<div class="value-container">
					<span class="value">0.0</span><span class="unit"></span>
				</div>
			</div>
		</div>
		
		<script>
			let baseURL = "";
			let userName = "";
			let password = "";
			window.onload = async function() {
				await loadSettings();  // Wait for the settings to load first
				updateGauge();         // Then call updateGauge after settings are loaded
				setInterval(updateGauge, 5000); // Set the interval to call every 5 seconds
			};
			
			const ENDPOINTS = {
				"powerDelivered": "power_delivered",
				"powerReturned": "power_returned",
				"secondary_indicator": "highest_peak_pwr",
			};
			
			const powerIndicator = document.querySelector(".primary_indicator");
			const secondaryIndicator = document.querySelector(".secondary_indicator");
			let indicatorValues = [];
			
			async function updateGauge() {
				try {
					const data = await fetchValues(); // Get all the JSON data
					
					let indicatorToConnect;
					let indicatorData;
					let htmlLabel;
					let htmlValue;
					let htmlUnit;
					
					let powerDelivered = null
					let powerReturned = null
					
					// Loop through the tagged data and
					// if the tag matches some indicator, automatically attach the data to that indicator
					Object.entries(data).forEach(([endpointTag, endpointData]) => {
						indicatorToConnect = document.querySelector("." + endpointTag);
						indicatorData = composeIndicatorData(endpointTag, endpointData);
						
						switch (endpointTag) {
							case "powerDelivered":
							powerDelivered = composeIndicatorData("powerDelivered", endpointData).value;
							break;
							case "powerReturned":
							powerReturned = composeIndicatorData("powerReturned", endpointData).value;
							
							if ((powerDelivered != null) && (powerReturned != null)) {
								nettoPower = powerDelivered - powerReturned;
								indicatorValues.push(nettoPower);
								
								// When everything is in place to update the gauge, do so
								if (powerIndicator && nettoPower) {
									htmlLabel = powerIndicator.querySelector(".label");
									htmlvalue = powerIndicator.querySelector(".value");
									htmlUnit = powerIndicator.querySelector(".unit");
									
									htmlLabel.textContent = "Netto Vermogen"; // Update label
									htmlvalue.textContent = nettoPower.toFixed(3);      // Update value
									htmlUnit.textContent = "kW";               // Update unit
								}
							}
							break;
							
							case "secondary_indicator":
							autoConnect(indicatorToConnect, indicatorData);
							break;
							
							default:
							console.warn("‚ö†Ô∏è No handler for endpoint: " + endpointTag);
							break;
						}
					});
					
					// Update gauge scale based on both indicatorValues
					updateGaugeScale(indicatorValues[0], indicatorValues[1]);
					
				} catch (error) {
					console.error("‚ùå Error in updateGauge:", error);
				}
			}
			
			function autoConnect(indicatorToConnect, indicatorData) {
				if ((indicatorToConnect != null) && (indicatorData != null)) {
					// Aways store values for indicators that can be autoconnected
					indicatorValues.push(indicatorData.value);
					
					// Select child elements within this indicator
					htmlLabel = powerIndicator.querySelector(".label");
					htmlvalue = powerIndicator.querySelector(".value");
					htmlUnit = powerIndicator.querySelector(".unit");
					
					// Update text content of the HTML elements
					htmlLabel.textContent = indicatorData.quantity;
					htmlvalue.textContent = indicatorData.value.toFixed(3);
					htmlUnit.textContent = indicatorData.unit ?? "";
				} else {
					console.error("‚ö†Ô∏è Autconnection indicator failed");
				}
			}
			
			function updateGaugeScale(nettoPower, maxPower) {
				// The angles used to define the gradient for the scale
				// are based on a system where zero degrees is midscale or 12 o'clock
				const gauge = document.querySelector(".gauge");
				
				// Define scale angles for the entire visible scale
				const minScale = -135;
				const maxScale = 135;
				
				// Define nominal range within the scale
				const nominalMin = -90;
				const nominalMax = 90;
				const midScale = 0;
				const nominalRange = 180;
				
				console.debug("[DEBUG] nettoPower:", nettoPower);
				console.debug("[DEBUG] maxPower:", maxPower);
				
				if (isNaN(nettoPower) || isNaN(maxPower)) {
					console.error("‚ùå Error: One or both values are NaN, cannot calculate currentAngle.");
					return;
				}
				
				// NettoPower expressed as an angle
				const percentage = (nettoPower / maxPower);
				const currentAngle = nominalMin + (percentage * nominalRange);
				console.debug("[DEBUG] Calculated currentAngle:", currentAngle);
				
				// Initialize gradient variables
				let gradientAngles = [minScale, nominalMin, midScale, nominalMax, maxScale];
				let gradientColors;
				
				switch (true) {
					case currentAngle <= nominalMin:
					// With negative values, colour in the lower left quadrant
					currentIndex = 1;
					gradientColors = ["transparant", "green", "transparant", "transparant", "transparant"];
					break;
					// With positive values that are below middle scale, colour in the upper left quadrant
					case currentAngle <= midScale:
					currentIndex = 2;
					gradientColors = ["transparant", "transparant", "green", "yellow", "orange", "red"];
					break;
					case currentAngle >= midScale:
					// with positive values that are below middle scale, colour in the upper right quadrant
					currentIndex = 3;
					gradientColors = ["transparant", "yellow", "orange", "red", "red"];
					break;
					case currentAngle >= nominalMax:
					// with positive values that are on or above middle scale, colour in the right quadrant
					currentIndex = 4;
					default:
					// out of range values to be handled later
					break;
				}
				
				gradientAngles.splice(currentIndex, 0, currentAngle);
				
				
				// Log gradient details before applying
				console.debug("[DEBUG] Gradient Angles:", gradientAngles);
				console.debug("[DEBUG] Gradient Colors:", gradientColors);
				console.debug("[DEBUG] Applying conic gradient from", minScale, "degrees.");
				
				// Define color constants
				colors = ["green", "yellow", "orange", "red"];
				
				// Define gradient angle constants
				gradientAngles = [-135, -90, 0, 90, 135];
				
				// Apply the conic gradient with smooth transitions
				gauge.style.background = `
 radial-gradient(var(--background) 0 var(--cutout), transparent var(--cutout) 100%),
 conic-gradient(from 225deg,green 0deg 45deg, orange, red 225deg 270deg, transparent 270deg 360deg)`;
 
 // Apply the conic
 console.debug("[DEBUG] ‚úÖ Gradient applied successfully.");
			}
			
			// Subroutines
			async function loadSettings() {
				try {
					const response = await fetch("/DSMRsettings.json");  // Fetch the config file from the ESP32
					if (!response.ok) throw new Error("‚ùå Failed to load config");
					
					const settings = await response.json();  // Parse JSON
					
					const hostName = settings.Hostname;
					baseURL = "http://" + hostName + ".local/api/v2/sm/fields/".toLowerCase();
					const credentials = settings["basic-auth"];
					userName = credentials.user;
					password = credentials.pass;
					
					console.debug("[DEBUG] ‚öôÔ∏è‚úÖ Settings loaded");
					
				} catch (error) {
					console.error("‚ùå Error loading config:", error);
				}
			}
			
			async function fetchValues() {
				const headers = new Headers();
				headers.set("Authorization", "Basic " + btoa(userName + ":" + password));
				headers.set("Content-Type", "application/json");
				
				const requests = Object.entries(ENDPOINTS).map(async ([endpointTag, endpoint]) => {
					const cleanbaseURL = baseURL.replace(/\/$/, ""); // Ensure baseURL does not end with '/'
					const cleanEndpoint = endpoint.replace(/^\//, ""); // Ensure endpoint does not start with '/'
					
					const url = cleanbaseURL + "/" + cleanEndpoint;
					try {
						console.debug("%c[DEBUG] ‚è¨Ô∏è Fetching: " + url, "color: grey;");
						const response = await fetch(url, { method: "GET", headers });
						
						if (!response.ok) {
							throw new Error("Error " + response.status + ": " + response.statusText);
						}
						const jsonData = await response.json();
						console.debug("[DEBUG] Received JSON data:", jsonData);
						console.debug("[DEBUG] üü¢‚á£ Response: ", jsonData);
						return [endpointTag, jsonData]; // Return as a key-value pair
						
					} catch (error) {
						console.error("‚ùå Fetch error for " + endpointTag + ":", error);
						return [endpointTag, null]; // Keep consistent structure
					}
				});
				
				// Await all requests and return as an object
				return Object.fromEntries(await Promise.all(requests));
			}
			
			function composeIndicatorData(endpointTag, endpointData) {
				const valuesKey = Object.keys(endpointData).find(key => key !== "timestamp"); // Find a key other than "timestamp"
				const values = endpointData[valuesKey]; // Get the values associated with that key
				const indicatorData = { quantity: endpointTag, ...values }; // Merge tag and values
				console.debug("[DEBUG] composeIndicatorData output:", indicatorData);
				return indicatorData;
			}
			
		</script>
	</body>
</html>
