<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<title>Vermogen Meter</title>
				<style>
					/* General Gauge Styles */
					.gauge {
						--size: 250px;
						--cutout: 50%;
						--background: white;
						width: var(--size);
						height: var(--size);
						border-radius: 50%;
						outline: 1.5px solid gray;
						box-shadow: inset 0 0 0 1.5px gray;
						display: flex;
						justify-content: center;
						align-items: center;
						position: relative;
						margin-top: 30px;
						margin-left: 60px;
					}
					
					.x-axis-line {
						position: absolute;
						top: 50%;
						left: -25%;
						width: 450px;
						height: 2px;
						background-color: grey;
						transform: translateY(-50%);
					}
					
					.indicator {
						position: absolute;
						font-size: 1.5rem;
						color: #666; /* Dimmed */
					}
					
					.label {
						font-weight: bold;
						white-space: nowrap; /* Prevent text from wrapping */
					}
					
					.value {
						padding-right: 5px;
					}
					
					.unit {
						font-size: 1.0rem;
						display: inline-flex;
					}
					
					#zero-indicator {
						left: -25%;
						text-align: right;
					}
					
					#primary-indicator {
						top: 50%;
						left: 50%;
						transform: translateX(-50%);
						text-align: center;
					}
					
					#rest-indicator {
						top: 100%; /* Move lower near the bottom of the gauge */
						left: 50%;
						transform: translateX(-50%);
						text-align: center;
						height: 60px; /* Adjust height */
					}
					
					#secondary-indicator {
						left: 100%; /* Place it to the right of the gauge */
						margin-left: 10px; /* Place it slightly to the right of the gauge */
						text-align: left;
						color: red;
					}
					
				</style>
			</head>
	<body>
		
		<div class="gauge">
			<div class="indicator" id="zero-indicator">
				<div class="label"></div>
				<span class="value">0.0</span><span class="unit" data-customUnit="kW">kW</span>
			</div>
			
			<div class="x-axis-line"></div>
			<div class="indicator" id="primary-indicator">
				<div class="label" data-customLabel="Netto Vermogen"></div>
				<div class="value-container">
					<span class="value">0.0</span> <span class="unit" data-customUnit="kW"></span>
				</div>
			</div>
			<div class="indicator" id="secondary-indicator">
				<div class="label" data-customLabel="Maandpiek"></div>
				<div class="value-container">
					<span class="value">0.0</span><span class="unit"></span>
				</div>
			</div>
			<div class="indicator" id="rest-indicator">
				<div class="label" data-customLabel="Nog over"></div>
				<div class="value-container">
					<span class="value">0.0</span><span class="unit" data-customUnit="kW"></span>
				</div>
			</div>
		</div>
		
		<script>
			let baseURL = "";
			let userName = "";
			let password = "";
			window.onload = async function() {
				await loadSettings();  // Wait for the settings to load first
				updateGaugeValues();         // Then call updateGaugeValues after settings are loaded
				setInterval(updateGaugeValues, 5000); // Set the interval to call every 5 seconds
			};
			
			const ENDPOINTS = {
				"powerDelivered": "power_delivered",
				"powerReturned": "power_returned",
				"secondary-indicator": "highest_peak_pwr",
			};
			
			const zeroIndicator = document.getElementById("zero-indicator");
			const powerIndicator = document.getElementById("primary-indicator");
			const maxPowerIndicator = document.getElementById("secondary-indicator");
			const restIndicator = document.getElementById("rest-indicator");
			let indicatorValues = [0];
			
			async function updateGaugeValues() {
				try {
					const data = await fetchValues(); // Get all the JSON data
					
					let indicatorToConnect;
					let indicatorData;
					let htmlLabel;
					let htmlValue;
					let htmlUnit;
					
					let powerDelivered = null;
					let powerReturned = null;
					let nettoPower = null;
					let maxPower = null;
					let restPower = null;
					
					// Loop through the tagged data store the values
					// if the tag matches some indicator, automatically attach the data to that indicator
					Object.entries(data).forEach(([endpointTag, endpointData]) => {
						
						indicatorToConnect = document.getElementById(endpointTag);
						indicatorData = composeIndicatorData(endpointTag, endpointData);
						
						switch (endpointTag) {
							case "powerDelivered":
							powerDelivered = composeIndicatorData("powerDelivered", endpointData).value;
							break;
							
							case "powerReturned":
							powerReturned = composeIndicatorData("powerReturned", endpointData).value;
							nettoPower = powerDelivered - powerReturned;
							indicatorValues.push(nettoPower);
							break;
							
							case "secondary-indicator":
							maxPower = indicatorData.value;
							if (maxPower <= 2.5) {
								maxPower = 2.5;
							}
							restPower = maxPower-nettoPower;
							if (restPower < 0) {
								restPower = 0;
							}
							connectDataset(indicatorToConnect, indicatorData);
							indicatorValues.push(maxPower);
							indicatorValues.push(restPower);
							break;
							
							default:
							console.warn("⚠️ No handler for endpoint: " + endpointTag);
							break;
						}
					});
					
					// Update indicators that use calculated values
					if (powerIndicator && nettoPower) {
						
						htmlLabel = powerIndicator.querySelector(".label");
						htmlvalue = powerIndicator.querySelector(".value");
						htmlUnit = powerIndicator.querySelector(".unit");
						
						htmlLabel.textContent = htmlLabel.getAttribute("data-customLabel");
						htmlvalue.textContent = nettoPower.toFixed(3);      // Update value
						htmlUnit.textContent = htmlUnit.getAttribute("data-customUnit");
					}
					
					// When everything is in place to update the gauge, do so
					if (restIndicator && restPower) {
						
						htmlLabel = restIndicator.querySelector(".label");
						htmlvalue = restIndicator.querySelector(".value");
						htmlUnit = restIndicator.querySelector(".unit");
						
						htmlLabel.textContent = htmlLabel.getAttribute("data-customLabel");
						htmlvalue.textContent = restPower.toFixed(3);      // Update value
						htmlUnit.textContent = htmlUnit.getAttribute("data-customUnit");
					}
					
					// Update gauge scale based on both indicatorValues
					updateGaugeStyle(nettoPower, maxPower);
					
				} catch (error) {
					console.error("❌ Error in updateGaugeValues:", error);
				}
			}
			
			
			function connectDataset(indicatorToConnect, indicatorData) {
				connectValues(indicatorToConnect, indicatorData.quantity, indicatorData.value, indicatorData.unit);
			}
			
			function connectValues(indicatorToConnect, label, value, unit) {
				
				if (indicatorToConnect != null) {
					
					// Select child elements within this indicator
					const htmlLabel = indicatorToConnect.querySelector(".label");
					const htmlvalue = indicatorToConnect.querySelector(".value");
					const htmlUnit = indicatorToConnect.querySelector(".unit");
					
					// Update text content of the HTML elements
					// Check to see if a custom label is provided
					const customLabel = htmlLabel.getAttribute("data-customLabel");
					if (customLabel != null) {  // Fix: added parentheses around condition
						htmlLabel.textContent = customLabel;
					} else {
						htmlLabel.textContent = label;
					}
					
					htmlvalue.textContent = value.toFixed(3);
					
					// Check to see if a custom unit is provided
					const customUnit = htmlUnit.getAttribute("data-customUnit");
					if (customUnit != null) {
						htmUnit.textContent = customUnit;
					} else {
						htmlUnit.textContent = unit;
					}
				}else {
					console.warn("⚠️ [connectValues] Indicator not found");
				}
			}
			
			function updateGaugeStyle(nettoPower, maxPower) {
				
				// The angles used to define the gradient for the scale
				// are based on a system where zero degrees is midscale or 12 o'clock
				// Gradients that start with a 'from' parameter will start at the specified angle and
				// gradientpoints are defined relative from that angle
				const gauge = document.querySelector(".gauge");
				
				// Define abosolute angle that the scale will start at
				const startOfScale = -135;
				
				// Define relative angles within that scale
				const minScale = 0;
				const nominalMin = 45;
				const nominalMax = 225;
				const maxScale = 270;
				
				// NettoPower expressed as an angle within the scale
				const percentage = (nettoPower / maxPower);
				const nominalRange = (nominalMax - nominalMin);
				let currentAngle = nominalMin+(percentage * nominalRange);
				// Always limit the angle within the defined ranges
				if (currentAngle <= minScale) {
					currentAngle = minScale;
				}
				if (currentAngle >= maxScale) {
					currentAngle = maxScale;
				}
				
				const gaugeCenter = `radial-gradient(var(--background) 0 var(--cutout), transparent var(--cutout) 100%)`;
				const gaugeScale = `conic-gradient(from ${startOfScale}deg, 
green ${minScale}deg ${nominalMin}deg, 
yellow,
orange, 
red ${nominalMax}deg ${maxScale}deg, 
transparent ${maxScale}deg 360deg
)`;
let scaleCover
if (nettoPower >= 0) {
	scaleCover = `conic-gradient(from ${startOfScale}deg, 
rgba(255, 255, 255, 0.85) ${startOfScale}deg ${nominalMin}deg, 
transparent ${nominalMin}deg ${currentAngle}deg,
rgba(255, 255, 255, 0.85) ${currentAngle}deg  ${maxScale}deg,
transparent ${maxScale}deg 360deg 
)`;
} else {
	scaleCover = `conic-gradient(from ${startOfScale}deg, 
rgba(255, 255, 255, 0.85) ${startOfScale}deg  ${currentAngle}deg,
transparent ${currentAngle}deg ${nominalMin}deg,
rgba(255, 255, 255, 0.85) ${nominalMin}deg ${maxScale}deg,
transparent ${maxScale}deg 360deg 
)`;
}

// Apply the gauge components as CSS background
gauge.style.background = `${scaleCover},${gaugeCenter},${gaugeScale}`;
			}
			
			// Subroutines
			async function loadSettings() {
				try {
					const response = await fetch("/DSMRsettings.json");  // Fetch the config file from the ESP32
					if (!response.ok) throw new Error("❌ Failed to load config");
					
					const settings = await response.json();  // Parse JSON
					
					const hostName = settings.Hostname;
					baseURL = "http://" + hostName + ".local/api/v2/sm/fields/".toLowerCase();
					const credentials = settings["basic-auth"];
					userName = credentials.user;
					password = credentials.pass;
					
					console.debug("[DEBUG] ⚙️✅ Settings loaded");
					
				} catch (error) {
					console.error("❌ Error loading config:", error);
				}
			}
			
			async function fetchValues() {
				const headers = new Headers();
				headers.set("Authorization", "Basic " + btoa(userName + ":" + password));
				headers.set("Content-Type", "application/json");
				
				const requests = Object.entries(ENDPOINTS).map(async ([endpointTag, endpoint]) => {
					const cleanbaseURL = baseURL.replace(/\/$/, ""); // Ensure baseURL does not end with '/'
					const cleanEndpoint = endpoint.replace(/^\//, ""); // Ensure endpoint does not start with '/'
					
					const url = cleanbaseURL + "/" + cleanEndpoint;
					try {
						console.debug("%c[DEBUG] ⏬️ Fetching: " + url, "color: grey;");
						const response = await fetch(url, { method: "GET", headers });
						
						if (!response.ok) {
							throw new Error("❌ Error " + response.status + ": " + response.statusText);
						}
						const jsonData = await response.json();
						console.debug("[DEBUG] Received JSON data:", jsonData);
						console.debug("[DEBUG] 🟢⇣ Response: ", jsonData);
						return [endpointTag, jsonData]; // Return as a key-value pair
						
					} catch (error) {
						console.error("❌ Fetch error for " + endpointTag + ":", error);
						return [endpointTag, null]; // Keep consistent structure
					}
				});
				
				// Await all requests and return as an object
				return Object.fromEntries(await Promise.all(requests));
			}
			
			function composeIndicatorData(endpointTag, endpointData) {
				const valuesKey = Object.keys(endpointData).find(key => key !== "timestamp"); // Find a key other than "timestamp"
				const values = endpointData[valuesKey]; // Get the values associated with that key
				const indicatorData = { quantity: endpointTag, ...values }; // Merge tag and values
				return indicatorData;
			}
			
			function setColorPrimaryIndicator(nettoPower, maxPower) {
				if (nettoPower < 0) {
					return "rgb(100, 200, 100)";  // Negative power (green for return power)
				} else if (nettoPower > maxPower) {
					return "rgb(220, 100, 100)";  // Over max power (red)
				} else {
					let ratio = value / maxValue;
					let red = Math.min(255, Math.floor(255 * ratio));
					let green = Math.max(0, Math.floor(200 - 200 * ratio));
					return `rgb(${red}, ${green}, 50)`;  // Gradient from green to red
				}
			}
			
		</script>
	</body>
</html>
