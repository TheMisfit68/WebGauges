<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<title>Vermogen Meter</title>
				<style>
					
					/* General Gauge Styles */
					.gauge {
						--size: 250px;
						--cutout: 50%;
						--background: white;
						width: var(--size);
						height: var(--size);
						border-radius: 50%;
						outline: 1.5px solid gray;
						box-shadow: inset 0 0 0 1.5px gray;
						background:
						radial-gradient(var(--background) 0 var(--cutout), transparent var(--cutout) 100%),
						conic-gradient(from -135deg, transparent 0deg, green 0deg 180deg, transparent 180deg 270deg, transparent 270deg);
						display: flex;
						justify-content: center;
						align-items: center;
						position: relative;
					}
					
					/* Primary Indicator */
					.primary_indicator {
						font-size: 2rem;
						font-weight: bold;
						color: rgb(100, 200, 100); /* Initial color */
						transition: color 0.2s linear;
						position: absolute;
						top: 30%;
					}
					
					.primary_indicator .label {
						font-size: 1.5rem;
						font-weight: bold;
						color: #666; /* Dimmed */
					}
					
					.primary_indicator .value {
						font-size: 2rem;
						font-weight: bold;
						color: #333;
						margin-bottom: 5px;
						transition: color 0.2s linear;
						display: flex; /* Enable flexbox */
						align-items: center; /* Vertically center the value and unit */
					}
					
					.primary_indicator .unit {
						font-size: 1rem;
						color: #888;
						margin-left: 5px; /* Add some spacing between the value and unit */
						white-space: nowrap; /* Prevent the unit from wrapping to a new line */
					}
					
					/* Secondary Indicator */
					.secondary_indicator {
						position: absolute;
						bottom: 10%;
						text-align: center;
					}
					
					.secondary_indicator .label {
						font-size: 1.5rem;
						font-weight: bold;
						color: #666; /* Dimmed */
					}
					
					.secondary_indicator .value {
						font-size: 1.5rem;
						font-weight: bold;
						color: #333;
						margin-bottom: 5px;
						transition: color 0.2s linear;
						display: flex; /* Enable flexbox */
						align-items: center; /* Vertically center the value and unit */
					}
					
					.secondary_indicator .unit {
						font-size: 1rem;
						color: #888;
						margin-left: 5px; /* Add some spacing between the value and unit */
						white-space: nowrap; /* Prevent the unit from wrapping to a new line */
					}
					
				</style>
			</head>
	<body>
		
		<div class="gauge">
			<div class="primary_indicator">
				<div class="label"></div>
				<div class="value">0.0</div><span class="unit"></span>
			</div>
			<div class="secondary_indicator">
				<div class="label"></div>
				<div class="value">0.0</div><span class="unit"></span>
			</div>
		</div>
		
		
		<script>
			
			let baseURL = "";
			let userName = "";
			let password = "";
			window.onload = async function() {
				await loadSettings();  // Wait for the settings to load first
				updateGauge();         // Then call updateGauge after settings are loaded
				setInterval(updateGauge, 5000); // Set the interval to call every 5 seconds
			};
			
			const ENDPOINTS = {
				"powerDelivered": "power_delivered",
				"powerReturned": "power_returned",
				"secondary_indicator": "highest_peak_pwr",
			};
			
			const powerIndicator = document.querySelector(".primary_indicator");
			const secondaryIndicator = document.querySelector(".secondary_indicator");
			
			async function updateGauge() {
				try {
					const data = await fetchValues(); // Get all the JSON data
					let indicatorToConnect;
					let indicatorData;
					let label;
					let value;
					let unit;
					
					// Declare powerDelivered and powerReturned at the top
					let powerDelivered;
					let powerReturned;
					let nettoPower;
					
					// Loop through the tagged data and
					// if the tag matches some indicator, automatically attach the data to that indicator
					Object.entries(data).forEach(([endpointTag, endpointData]) => {
						
						indicatorToConnect = document.querySelector("." + endpointTag);
						indicatorData = composeIndicatorData(endpointTag, endpointData);
						
						autoConnect = indicatorToConnect && indicatorData;
						manualConnect = !indicatorToConnect && indicatorData;
						
						if (autoConnect){
														
							// Select child elements within this indicator
							label = indicatorToConnect.querySelector(".label");
							value = indicatorToConnect.querySelector(".value");
							unit = indicatorToConnect.querySelector(".unit");
							
							// Update text content of the HTML elements
							if (label) label.textContent = indicatorData.quantity;
							if (value) value.textContent = indicatorData.value ?? "___";
							if (unit) unit.textContent = indicatorData.unit ?? "";
							
						}else if (manualConnect){
							
							switch(endpointTag){
								
								case "powerDelivered":
								powerDelivered = composeIndicatorData("powerDelivered", endpointData).value;
								break;
								case "powerReturned":
								powerReturned = composeIndicatorData("powerReturned", endpointData).value;
								
								if ( (powerDelivered != null) && (powerReturned != null) ) {
									nettoPower = powerDelivered - powerReturned;
																		
									// When everything is in place to update the gauge, do so
									if (powerIndicator && nettoPower) {
										
										label = powerIndicator.querySelector(".label");
										value = powerIndicator.querySelector(".value");
										unit = powerIndicator.querySelector(".unit");
																			
										if (label) label.textContent = "Netto Vermogen"; // Update label
										if (value) value.textContent = nettoPower;      // Update value
										if (unit) unit.textContent = "kW";               // Update unit
									}
									
								}
								break;
								
								default:
								console.warn("⚠️ No handler for endpoint: " + endpointTag);
								break;
							}
						}
					});
					
				} catch (error) {
					console.error("❌ Error in updateGauge:", error);
				}
			}
			
			// Subroutines
			async function loadSettings() {
				try {
					const response = await fetch("/DSMRsettings.json");  // Fetch the config file from the ESP32
					if (!response.ok) throw new Error("❌ Failed to load config");
					
					const settings = await response.json();  // Parse JSON
					
					const hostName = settings.Hostname;
					baseURL = "http://" + hostName + ".local/api/v2/sm/fields/".toLowerCase();
					const credentials = settings["basic-auth"];
					userName = credentials.user;
					password = credentials.pass;
					
					console.log("⚙️✅ Settings loaded");
					
				} catch (error) {
					console.error("❌ Error loading config:", error);
				}
			}
			
			async function fetchValues() {
				const headers = new Headers();
				headers.set("Authorization", "Basic " + btoa(userName + ":" + password));
				headers.set("Content-Type", "application/json");
				
				const requests = Object.entries(ENDPOINTS).map(async ([endpointTag, endpoint]) => {
					const cleanbaseURL = baseURL.replace(/\/$/, ""); // Ensure baseURL does not end with '/'
					const cleanEndpoint = endpoint.replace(/^\//, ""); // Ensure endpoint does not start with '/'
					
					const url = cleanbaseURL + "/" + cleanEndpoint;
					try {
						console.log("%c⏬️ Fetching: " + url, "color: grey;");
						const response = await fetch(url, { method: "GET", headers });
						
						if (!response.ok) {
							throw new Error("Error " + response.status + ": " + response.statusText);
						}
						const jsonData = await response.json();
						console.log("🟢⇣ Response: ", jsonData);
						return [endpointTag, jsonData]; // Return as a key-value pair
						
					} catch (error) {
						console.error("❌ Fetch error for " + endpointTag + ":", error);
						return [endpointTag, null]; // Keep consistent structure
					}
				});
				
				// Await all requests and return as an object
				return Object.fromEntries(await Promise.all(requests));
			}
			
			function composeIndicatorData(endpointTag, endpointData) {
				
				const valuesKey = Object.keys(endpointData).find(key => key !== "timestamp"); // Find a key other than "timestamp"
				const values = endpointData[valuesKey]; // Get the values associated with that key
				const indicatorData = { quantity: endpointTag, ...values }; // Merge tag and values
				
				return indicatorData;
			}
			
			// Function to update the color based on power value
			function getColor(value, maxValue) {
				if (value < 0) {
					return "rgb(100, 200, 100)";  // Negative power (green for return power)
				} else if (value > maxValue) {
					return "rgb(220, 100, 100)";  // Over max power (red)
				} else {
					let ratio = value / maxValue;
					let red = Math.min(255, Math.floor(255 * ratio));
					let green = Math.max(0, Math.floor(200 - 200 * ratio));
					return "rgb(" + red + ", " + green + ", 50)";  // Gradient from green to red
				}
			}
			
		</script>
	</body>
</html>
